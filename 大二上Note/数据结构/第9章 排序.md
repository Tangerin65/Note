# 0.基本概念
 - 比较关键字的大小->调整记录的位置
 - 分类：
	 - 静态/动态
	 - 内部/外部；
	 - 插入/选择/交换/归并/基数 
	 - ……(具体去看PPT)

---
# 1.插入排序
把无序子序列里的记录插入有序子序列中
### 1.1.直接插入排序
 - 把无序序列里的第一个元素插入有序序列的对应位置(有序序列可以只有1个元素)
 - 迭代n-1次
 - 时间复杂度：$O(n)$~$O(n^2)$, 平均后者
 - 执行次数：
	 - 最坏情况[[Chapter9-10教材.pdf#page=3&selection=243,7,253,3&color=red|Chapter9-10教材, p.3]]
	 - 最好情况[[Chapter9-10教材.pdf#page=3&selection=379,0,392,1&color=red|Chapter9-10教材, p.3]]
 - 例子：[[Chapter9-10教材.pdf#page=2&selection=101,0,101,3&color=yellow|Chapter9-10教材, p.2]]
![[Chapter9-10教材.pdf#page=3&rect=320,285,590,456&color=yellow|Chapter9-10教材, p.3]]
### 1.2.折半(二分)查找
### 1.3.希尔(Shell)排序
 - 对记录：先宏观调整，再微观调整
 - 或者说：含有子序列的插入排序
 - 过程：将n个记录分为d个子序列：
	   {R[1],R[1+d],R[1+2d]……R[1+kd]}，d为增量，即元素之间的gap
	   比如：16|25|12|30|47 , d=2, 则16和30是一组，25和47一组，12一组
	   在子序列(组)内进行插入排序
	   然后取另一个d，进行下一次分组和下一次插入排序，直到排序完成
 - 时间复杂度：[[Chapter9-10教材.pdf#page=5&selection=163,17,182,2&color=yellow|Chapter9-10教材, p.5]]
 - 例子：![[Chapter9-10教材.pdf#page=4&rect=302,284,597,536&color=yellow|Chapter9-10教材, p.4]]
 - gap的取法：每次折半/$\frac{n}{3}+1$,但最后一次**一定为1** 

---
# 2.交换排序
交换无序子序列内元素，使最值先移动到对应位置，以此类推
### 2.1.冒泡排序
 - 基本思路：[[Chapter9-10教材.pdf#page=5&selection=211,11,244,6&color=yellow|Chapter9-10教材, p.5]]，从上到下两两比较并交换，使得最大元素沉底，忽略最大气元素后重复冒泡排序。
 - 例子：![[Chapter9-10教材.pdf#page=6&rect=370,553,593,725&color=yellow|Chapter9-10教材, p.6]]
 - 优化：**当排序提前完成时提前终止**：if最近一次排序无交换
 - 代码实现：两重循环[[Chapter9-10教材.pdf#page=6&selection=19,0,19,9&color=yellow|Chapter9-10教材, p.6]]
 - 时间复杂度：$O(n^2)$，非优化下不管是最好还是最坏都是这么多，但优化后就要具体问题具体分析了

### 2.2.快速排序
<font color=red>Significant,代码要会写</font>[[Chapter9-10教材.pdf#page=7&selection=246,0,250,7&color=red|Chapter9-10教材, p.7]]
 - 基本思路：任取一个元素作为枢轴，将其他元素和他比较，把序列分成两个部分，重复这一步骤，直到排序完成
 - 例子解析：![[Chapter9-10教材.pdf#page=8&rect=30,208,591,493&color=red|Chapter9-10教材, p.8]]
	 定义两个指针low/high
	 最开始49是枢轴,我们先从大往小找比49小的元素,high目前指向的68>49,high--
	 下一个high38<49,因此交换38和49
	 接下来从小往大找比49大的元素，遇到前两个38就low++
	 遇到66>49，交换两者
	 然后再反过来动high，97>49
	 
 - 时间复杂度：$O(nlogn)$,[[Chapter9-10教材.pdf#page=9&selection=442,0,451,2&color=yellow|Chapter9-10教材, p.9]],
	 - 最坏情况：初始序列有序时反倒会导致算法退化，[[Chapter9-10教材.pdf#page=9&selection=461,14,465,1&color=red|Chapter9-10教材, p.9]]
 - 取枢轴的改进方法：取第一个&最后一个&中间那一个三者比大小后，取中间者为枢轴

---
# 3.选择排序
在无序序列中选择最值并加入有序子序列中
### 3.1.简单选择排序
 - 基本思路：在无序序列中遍历选最小值，它肯定比旁边有序序列所有元素大（因为比他小的都在更早的选择中被塞到有序序列中了），放到有序序列的最大位置，重复
 - 例子：![[Chapter9-10教材.pdf#page=10&rect=63,148,591,329&color=red|Chapter9-10教材, p.10]]
 - P.S.
 - 时间复杂度：$O(n^2)$[[Chapter9-10教材.pdf#page=10&selection=429,0,435,3&color=yellow|Chapter9-10教材, p.10]]
 - 辨析：
	 - **插入排序**：“左手已有序，右手摸一张，插到左手里合适的位置”
	 - **选择排序**：“左手已有序，从右手全部人里挑一个最小的，站到左手队尾”

### 3.2.堆排序
<font color=blue>动态排序算法</font>：排序过程中可以有新元素加入
 - 基本思路：[[Chapter9-10教材.pdf#page=11&selection=28,0,116,13&color=red|Chapter9-10教材, p.11]]不太好理解，仔细看看。
	 - 利用堆“最值一定在堆顶/二叉树根节点”特性进行排序
	 - 用二叉树理解：[[Chapter9-10教材.pdf#page=11&selection=135,9,160,1&color=red|Chapter9-10教材, p.11]]，
		 - 小顶堆：父节点<子节点
		 - 大顶堆：父节点>子节点
		 - 左右子树无明确大小关系
 - 堆的建立：先直接把整个序列塞入一颗完全二叉树，不管顺序；然后再进行调整，具体可参考下图例子
 - 例子：![[Chapter9-10教材.pdf#page=12&rect=101,513,567,745&color=yellow|Chapter9-10教材, p.12]]
	这是大顶堆，内部交换：
		1. 初始堆：如果缺失根结点(a&c)：用最底下的叶子结点交换，避免破坏树中结构
		2. 筛选：如果是交换内部大小顺序(b)：通过从右往左找第一个非叶子节点(48 in b)，往下按大在上的顺序交换子树内部元素。

---
# 4.归并排序
合并两个及以上的有序子序列
 - 基本思路：新建一个足够放下两个子序列的空间(空间换时间)

---
# 5.基数排序
利用多关键字排序

